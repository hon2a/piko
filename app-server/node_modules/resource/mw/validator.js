var Chaos = require('Chaos'),
	HTTP = require('http-status'),
	util = require('util'),
	fn = require('functions');

var validators = {
		eq: function (val, a) {
			return (val === a) ||
					util.format('Value is not equal to %s.', fn.quote(a));
		}
	},
	validateItem = function (valiCfg, value, callback) {
		var result = true;
		if (valiCfg) {
			valiCfg = fn.isString(valiCfg) ? [valiCfg] : valiCfg;
			if (fn.isArray(valiCfg)) {
				var name = valiCfg[0];
				if (validators[name]) {
					validators[name].apply(module, [value].concat(valiCfg.slice(1)));
				} else {
					result = util.format('Validator %s not found.', fn.quote(name));
				}
			} else if (util.isRegExp(valiCfg)) {
				result = valiCfg.test(value) ||
						util.format('Value does not match expression %s.', valiCfg);
			}
		}

		result = (result === false) ?
			util.format('Value %s forbidden by unspecified restriction.', fn.quote(value)) :
			result;
		callback(result || null);
	};

var validator = module.exports = function (config) {
	
	return function (req, res, action, next) {
		if (config[action] || config.all) {
			var cfg = fn.merge({}, config[action] || {}, config.all),
				actions = new Chaos(),
				keys = Object.keys(req.data || {});
			keys.forEach(function (value, key) {
				var valiCfg = cfg[key];
				if (valiCfg) {
					actions.add(function (callback) {
						validateItem(valiCfg, value, callback);
					});
					delete cfg[key];	// remove used config to find missing items
				} else if (valiCfg !== false) {
					delete req.data[key];
				}
			});

			actions.run(function (err, results) {
				if (err) {
					res.send(util.format('Invalid value of argument %s. %s',
							fn.quote(keys[results.length]), err), HTTP.BAD_REQUEST);
				} else {
					var missing = Object.keys(cfg);
					if (missing.length) {
						res.send(util.format('Missing mandatory arguments %s.',
								missing.map(fn.quote).join(', ')), HTTP.BAD_REQUEST);
					} else {
						next();
					}
				}
			});
		} else {
			next();
		}
	};
};