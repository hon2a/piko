var path = require('path'),
	crypto = require('crypto'),
	util = require('util');

module.exports = fn = {

	array: function (val, from, to) {
		return Array.prototype.slice.call(val, from || 0, to);
	},

	each: function (collection, callback, scope) {
		scope = scope || module;
		if (util.isArray(collection)) {
			collection.forEach(callback, scope);
		} else if (fn.isObject(collection)) {
			Object.keys(collection).forEach(function (key) {
				callback.call(scope, collection[key], key);
			});
		} else {
			throw 'Object is not a collection.';
		}
	},

	handleError: function (err, message, callback) {
		if (!err) {
			return false;
		}

		// handleError(error, callback)
		if (fn.isFunction(message)) {
			callback = message;
			message = '';
		}

		err = (!message && util.isError(err)) ? err : new Error(message + ' ' + err);

		callback(err);
		return true;
	},

	isBoolean: function (val) {
		return (typeof val === 'boolean');
	},

	isError: function (val) {
		return (val instanceof Error);
	},

	isFunction: function (val) {
		return (typeof val === 'function');
	},

	isNumber: function (val) {
		return (typeof val === 'number');
	},

	isInt: function (val) {
		return ((parseInt(val, 10).toString()) === val);
	},

	isObject: function (val) {
		return (typeof val === 'object');
	},

	isString: function (val) {
		return (typeof val === 'string');
	},

	md5: function (str) {
		return crypto.createHash('md5').update(str).digest('hex');
	},

	merge: function (dest, source, defaults) {
		var key;
		if (defaults !== undefined) {
			for (key in defaults) {
				dest[key] = dest[key] || defaults[key];
			}
		}
		for (key in source) {
			dest[key] = source[key];
		}
		return dest;
	},

	noop: function () {},

	notImplemented: function (filename, method) {
		return new Error('Abstract method ' + path.basename(filename, '.js') +
				'::' + method + '() is not implemented!');
	},

	/**
	 * @param {Object} obj
	 * @param {Array} props
	 */
	pick: function (obj, props) {
		var ret = {};
		props.forEach(function (prop) {
			ret[prop] = obj[prop];
		});
		return ret;
	},

	proxy: function (callback, scope) {
		callback = callback || function () {};
		scope = scope || module;
		return function () {
			callback.apply(scope, arguments);
		};
	},

	quote: function (value) {
		return '\'' + value + '\'';
	}

};